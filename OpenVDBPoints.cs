using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering;
using Unity.Collections;
using System.Runtime.InteropServices;
using System;
using System.IO;
using System.Linq;

namespace OpenVDBPointsUnity
{
    /// <summary>Native interface for OpenVDB Points Module</summary> 
    public sealed class OpenVDBPoints
    {
        #if UNITY_EDITOR_OSX || UNITY_STANDALONE_OSX
        private const string libraryName = "libopenvdb-points-unity";
        #else 
        private const string libraryName = "openvdb-points-unity";
        #endif
        /// <summary>The absolute path to the .vdb file on disk.</summary>
        /// <remarks>Note- must be an absolute path.</remarks>
        public string FilePath { get; set; }
        public uint Count
        {
            get
            {
                if (!countCalculated)
                {
                    GetCount();
                }
                return count;
            }
        }
        public string Name { get; private set; }
        private NativeArray<Vertex> vertices;
        public Mesh mesh { get; private set; }

        /// <summary>
        /// Constructor that takes an absolute path to the .vdb 
        /// file containing the PointDataGrid and initializes OpenVDB. 
        /// </summary>
        /// <param name="filePath">Absolute path to the .vdb file</param>
        public OpenVDBPoints(string filePath)
        {
            FilePath = filePath;
            Initialize();
        }
        /// <summary>Parameterless constructor that initializes OpenVDB</summary>
        public OpenVDBPoints() { Initialize(); }

        /// <summary>
        /// Finalizer that deletes the <see cref="gridRef">pointer</see> 
        /// to the SharedPointDataGrid reference.
        /// </summary>
        ~OpenVDBPoints()
        {
            if (gridRef != IntPtr.Zero)
            {
                destroySharedPointDataGridReference(gridRef);
            }
        }
        /// <summary>Pointer to native SharedPointDataGrid.</summary>
        private IntPtr gridRef;
        private uint count = 0;
        private bool countCalculated = false;
        /// <summary>
        /// Callback signature for logging messages from the native side.
        /// </summary>
        /// <param name="message">The message generated by the native plugin.</param>
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void LoggingCallback(string message);
        /// <summary>The default grid name used to access the PointDataGrid.</summary>
        // private const string gridName = "";
        private const string gridName = "Points";
        /// <summary>Wrapper for openvdb::initialize.</summary>
        [DllImport(libraryName)]
        private static extern void openvdbInitialize();
        /// <summary>Loads a PointDataGrid from a file.</summary>
        /// <param name="filename">Absolute path to a .vdb file containing the grid.</param>
        /// <param name="gridName">The name of the grid to load.</param>
        /// <param name="cb">The <see cref="LoggingCallback">callback</see> for logging native messages.</param>
        /// <returns>A pointer to the SharedPointDataGridReference on the native side. </returns>
        [DllImport(libraryName, CallingConvention = CallingConvention.Cdecl)]
        private static extern IntPtr readPointGridFromFile(string filename, string gridName, LoggingCallback cb);
        /// <summary>The total number of points in a PointDataGrid.</summary>
        /// <param name="gridRef">Pointer to the SharedPointDataGridReference on the native side.</summary>
        /// <returns>The total number of points in the grid.</returns>
        [DllImport(libraryName, CallingConvention = CallingConvention.Cdecl)]
        private static extern uint getPointCountFromGrid(IntPtr gridRef);
        /// <summary>
        /// Deletes a SharedPointDataGridReference and its corresponding PointDataGrid.
        /// </summary>
        /// <param name="gridRef">Pointer to the SharedPointDataGridReference on the native side.</summary>
        [DllImport(libraryName)]
        private static extern void destroySharedPointDataGridReference(IntPtr gridRef);
        /// <summary> Converts an unordered point cloud from a .ply file to VDB format. </summary>
        /// <param name="filename">The absolute path to the .ply file. </param>
        /// <param name="outfile">The absolute path to the .vdb file. </param>
        /// <param name="cb">The <see cref="LoggingCallback">callback</see> for logging native messages.</param>
        /// <returns>True if the file was successfully converted,  false  if not. </returns>
        /// <remarks>Currently only supports vertex positions (float) and colors (uint8) </remarks>
        [DllImport(libraryName, CallingConvention = CallingConvention.Cdecl)]
        private static extern bool convertPLYToVDB(string filename, string outfile, LoggingCallback callback);

        [DllImport(libraryName)]
        private static extern IntPtr generatePointArrayFromPointGrid(IntPtr gridRef, LoggingCallback cb);

        [DllImport(libraryName)]
        private static extern IntPtr generateColorArrayFromPointGrid(IntPtr gridRef);

        [DllImport(libraryName)]
        private static extern IntPtr arraysToPointGrid(IntPtr positionArr, IntPtr colorArr, int count);

        [DllImport(libraryName)]
        unsafe private static extern void populateVertices(void* verts, IntPtr gridRef, LoggingCallback cb);

        /// <summary>Initializes OpenVDB.</summary>
        private void Initialize()
        {
            openvdbInitialize();
        }
        /// <summary> Loads a PointDataGrid from <see cref="FilePath" />.</summary>
        /// <param name="gridName">The name of the grid to load.</param>
        /// <param name="cb">The optional <see cref="LoggingCallback">callback</see> for logging native messages.</param>
        /// <remarks> <see cref="FilePath"/> must be set in order to load the grid.</remarks>
        /// <exception cref="Exception">The file is not found, or <see cref="FilePath"/> is not set.</exception>
        public void Load(string name = null, LoggingCallback cb = null)
        {
            if (string.IsNullOrEmpty(FilePath))
            {
                throw new Exception("FilePath must be set in order to load a PointDataGrid");
            }
            if (!File.Exists(FilePath))
            {
                throw new FileNotFoundException(string.Format("{0} could not be found!", FilePath));
            }
            string grid = name == null ? gridName : name;
            LoggingCallback logger = cb == null ? LogMessage : cb;
            gridRef = readPointGridFromFile(FilePath, grid, logger);
        }

        /// <summary> Loads a PointDataGrid from point and color arrays. </summary>
        /// <remarks> This is probably a dumb interface, since the conversion to Vector3 is only used to transfer from the texture to this, but we'll see </remarks>
        public void Load(Vector3[] points, Color[] colors)
        {
            if (points.Length != colors.Length)
                throw new Exception("Point and color array sizes must match!");

            Vec3d[] ptArr = points.Select(pt => new Vec3d(pt)).ToArray();
            Vec3d[] colArr = colors.Select(col => new Vec3d(col)).ToArray();

            gridRef = arraysToPointGrid(ArrToIntPtr<Vec3d>(ptArr), ArrToIntPtr<Vec3d>(colArr), points.Length);
        }

        [StructLayout(LayoutKind.Sequential)]
        struct Vertex
        {
            public Vector3 pos;
            public Color32 color;
        }

        public void InitializeMesh()
        {
            int intCount = (int)Count;  // This is really bad -- should create two arrays and probably meshes for counts > max int

            vertices = new NativeArray<Vertex>(intCount, Allocator.Temp);
            unsafe {
                populateVertices(Unity.Collections.LowLevel.Unsafe.NativeArrayUnsafeUtility.GetUnsafePtr(vertices), gridRef, LogMessage);
            }

            mesh = new Mesh();
            mesh.SetVertexBufferParams(intCount, new []{
                new VertexAttributeDescriptor(VertexAttribute.Position, VertexAttributeFormat.Float32, 3),
                new VertexAttributeDescriptor(VertexAttribute.Color, VertexAttributeFormat.UNorm8, 4),
            });

            mesh.SetVertexBufferData(vertices, 0, 0, intCount);

            mesh.SetIndices(
                Enumerable.Range(0, vertices.Length).ToArray(),
                MeshTopology.Points, 0
            );
        }

        /// <summary>
        /// The total number of points contained in a PointDataGrid referenced by <see cref="gridRef"/>.
        /// </summary>
        /// <returns>The total point count.</returns>
        private void GetCount()
        {
            if (gridRef != IntPtr.Zero)
            {
                count = getPointCountFromGrid(gridRef);
            }
            else
            {
                throw new Exception("A PointDataGrid must be loaded in order to get a point count!");
            }
        }
        /// <summary> Converts an unordered point cloud from a .ply file to VDB format. </summary>
        /// <param name="filename">The absolute path to the .ply file. </param>
        /// <param name="outfile">The absolute path to the .vdb file. </param>
        /// <param name="cb">The optional <see cref="LoggingCallback">callback</see> for logging native messages.</param>
        /// <returns>True if the file was successfully converted,  false  if not. </returns>
        /// <remarks>Currently only supports vertex positions (float) and colors (uint8) </remarks>
        public static bool ConvertPLYToVDB(string filename, string outfile, LoggingCallback cb = null)
        {
            LoggingCallback logger = cb == null ? LogMessage : cb;
            openvdbInitialize();
            return convertPLYToVDB(filename, outfile, logger);
        }
        /// <summary> Default <see cref="LoggingCallback">callback</see> for logging native messages. </summary> 
        private static void LogMessage(string message)
        {
            Debug.Log(message);
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct Vec3d
        {
            public double x;
            public double y;
            public double z;
        
            // for debugging
            public override String ToString()
            {
                return "{" + x + ","+ y + "," + z + "}";
            }

            public Vector3 ToVector3()
            {
                return new Vector3((float)x, (float)y, (float)z);
            }

            public Color ToColor()
            {
                return new Color((float)x, (float)y, (float)z, 1);
            }

            public Vec3d(Vector3 vec)
            {
                this.x = (double)vec.x;
                this.y = (double)vec.y;
                this.z = (double)vec.z;
            }

            public Vec3d(Color col)
            {
                this.x = (double)col.r;
                this.y = (double)col.g;
                this.z = (double)col.b;
            }
        }

        /// <summary> Converts a VDB grid to an array of Vector3 for mesh construction </summary>
        public Vector3[] GenerateVertexArray()
        {
            if (gridRef != IntPtr.Zero)
            {
                return IntPtrToArr<Vec3d>(generatePointArrayFromPointGrid(gridRef, LogMessage), Count).Select(pt => pt.ToVector3()).ToArray();
            }
            else
            {
                throw new Exception("A PointDataGrid must be loaded in order to generate a point array!");
            }
        }

        public Color[] GenerateColorArray()
        {
            if (gridRef != IntPtr.Zero)
            {
                return IntPtrToArr<Vec3d>(generatePointArrayFromPointGrid(gridRef, LogMessage), Count).Select(pt => pt.ToColor()).ToArray();
            }
            else
            {
                throw new Exception("A PointDataGrid must be loaded in order to generate a point array!");
            }
        }

        /// <remarks> Taken from https://bravenewmethod.com/2017/10/30/unity-c-native-plugin-examples/ </remarks>
        static T[] IntPtrToArr<T>(IntPtr arrPtr, uint arrSize)  // Should be able to improve this with MarshalAsAttribute?
        {
            T[] result = new T[arrSize];
            int offset = 0;
            int tSize = Marshal.SizeOf(typeof(T));
            for (int i = 0; i < arrSize; i++)
            {
                // Hopefully this works
                try
                {
                    result[i] = (T)Marshal.PtrToStructure(new IntPtr(arrPtr.ToInt32() + offset), typeof(T));
                }
                catch
                {
                    result[i] = (T)Marshal.PtrToStructure(new IntPtr(arrPtr.ToInt64() + offset), typeof(T));
                }
                offset += tSize;
            }

            Marshal.FreeCoTaskMem(arrPtr);
            return result;
        }

        /// <summary> Converts array to int ptr, returns intptr, size </summary>
        /// <remarks> Originally considered returning size in tuple, but they already have array </remarks>
        static IntPtr ArrToIntPtr<T>(T[] arr)
        {
            int tSize = Marshal.SizeOf(typeof(T));
            IntPtr arrPtr = Marshal.AllocHGlobal(tSize * arr.Length);

            for (int i = 0; i < arr.Length; i++)
            {
                try
                {
                    Marshal.StructureToPtr(arr[i], new IntPtr(arrPtr.ToInt32() + (tSize*i)), false);

                }
                catch
                {
                    Marshal.StructureToPtr(arr[i], new IntPtr(arrPtr.ToInt64() + (tSize*i)), false);
                }
            }

            return arrPtr;
        }
    }
}
